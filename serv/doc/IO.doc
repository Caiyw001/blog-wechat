I/O模型
1、阻塞式I/O模型
2、非阻塞式I/O模型
3、I/O复用
4、信号驱动I/O模型
5、异步I/O模型

文件描述符 file description  fd
linux内核将素有外部设备都看作一个文件来操作，对于一个文件的读写操作会调用内核提供的系统命令，返回一个file descriptor, 
对于scoket的读写也会有相应的描述符，称为scoket fd

内核缓冲区
应用进程缓冲区

1、阻塞式I/O
应用进程 系统调用recvfrom接收数据，但是此时的 内核缓存区中数据还没有准备好，应用进程会一直阻塞到内核缓冲区有数据报到达且被复制到应用缓存区
一个输入操作一般分为两个阶段
两个阶段
1、等待数据包准备好 通常是等待数据从网络上到达，党所等待的分组数据到达后，会被复制到内核的某个缓冲区
2、从内核想应用进程复制数据
例子:商场排队吃饭，只能老老实实排队，并且排队的时候不能做其他事情

2、非阻塞式I/O
套接字设置为非阻塞，当应用进程 系统调用recvfrom接收数据，但是此时的数据没有准备好，内核会立即返回一个EWOULDBLOCK 错误，而不是一直阻塞到数据准备好，
应用进程 系统调用recvfrom，数据没有准备好之前，内核都会返回EWOULDBLOCK ，直到数据准备好，这是数据会被复制到应用进程缓存区
应用进程使用这个方式，循环调用recvfrom时，我们称之为轮询 polling,这么做往往会耗费大量CPU时间，实际使用很少
例子
还是商场吃饭，只是现在可以取号了。不过仍然需要时不时的去看一下有没有叫到号


3、I/O复用
Linux I/O复用模型提供了select poll epoll三组系统调用可做选择，进程通过将一个或多个文件描述符(fd)传递给select或poll或epoll系统调用，
通过它们来监测多个fd是否处于就绪状态。select或poll是顺序扫描fd是否就绪，而且支持的fd数量有限，因此使用上有制约。
epoll调用基于事件驱动，因此性能更高，当fd就绪时会立即回调rollback
例子
还是商场吃饭，但是现在你可以在手机APP上同时叫多个号了，只要多个号里面有一个号好了就会通知你了

4、信号驱动I/O
信号驱动I/O的意思就是我们现在不用傻等着了，也不用去轮询。而是让内核在数据就绪时，发送信号通知我们。
调用的步骤是，我们通过系统调用sigaction，并注册一个信号处理的回调函数，该调用会立即返回，但是当内核数据就绪时，内核会为该进程产生一个SIGIO信号，
并回调我们注册的信号回调函数，这样我们就可以在信号回调函数中系统调用recvfrom获取数据
例子
商场吃饭，只要取了号，你也不用去一直看看大屏幕有没有好了，要是叫到号了，会主动发消息告诉你了

5、异步I/O
异步I/O 与 信号驱动I/O最大区别在于，信号驱动是内核通知我们何时开始一个I/O操作，而异步I/O是由内核通知我们I/O操作何时完成，两者有本质区别
例子
都不用去商场吃饭了，直接点个外卖，把等待上菜的时间也给省了